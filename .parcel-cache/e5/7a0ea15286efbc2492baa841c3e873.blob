{"mappings":"YAAAA,QAAQC,IAAI,UAERC,EAAOC,SAASC,eAAe,QAE/BC,EAAQF,SAASG,cAAc,UAC/BC,EAAAA,67EA8IAC,EAAU,GAKVC,EAAI,EAGJC,EAAO,KACPC,YAAW,KACJT,IACmB,OAAdK,EAAOE,GACPD,GAAW,OACU,MAAdD,EAAOE,GAEdD,GAAW,QAGXA,GAAWD,EAAOE,GAEtBP,EAAKU,UAAYJ,EACdH,IACCA,EAAMO,UAAYL,EAAOM,UAAU,EAAGJ,IAE1CK,OAAOC,SAAS,EAAE,MAClBb,EAAKa,SAAS,EAAE,MACZN,EAAIF,EAAOS,OAAS,IAEpBN,IACAD,QAIT,KAEPC","sources":["./main.ts"],"sourcesContent":["console.log(\"hi\")\n// var yinyang = document.getElementById(\"yinyang\")\nlet html = document.getElementById('html')\n// 写样式\nlet style = document.querySelector('#style')\nlet string = `\n/*你好，html我们已经写好了,接下来我要加样式了。\n首先,去掉浏览器自带的样式。*/\n\n* {\n    margin: 0;\n    padding: 0;\n    font-size: 10px;\n    box-sizing: border-box;\n  }\n*::after {\n  box-sizing: border-box;\n}\n*::before {\n  box-sizing: border-box;\n}\n\n/*然后*/\n#html {\n  word-break: break-all;\n}\n\n/*修改一下背景颜色*/\nbody{\n    background: #ddd;\n}\n\n\n/*使用css border调试大法。\nborder: 1px solid red;这样就可以看到我要操作的内容了。\n我要加的样式是：将id=\"yinyang\"的div宽高设置成200px*/\n#yinyang{\n    border: 1px solid white;\n    width: 200px;\n    height: 200px;\n}\n\n/*让div居中*/\n#yinyang{\n    /* 相对定位 */\n    position: relative;\n        /* 居中 */\n    margin: 100px auto;\n\n}\n\n/*一步步来，想做八卦先做一个圆。*/\n#yinyang{\n    border-radius: 50%;\n}\n/*\n圆画好了，下一步怎么做呢？\n在圆中画个 S 当然这样挺难，我们把圆对半分。\n八卦是阴阳两极之相。\n我们先绘制一下阴阳两极。\n*/\n#yinyang{\n    background: linear-gradient(180deg, rgba(255,255,255,1) 0%, rgba(255,255,255,1) 50%, rgba(0,0,0,1) 50%, rgba(0,0,0,1) 100%);\n}\n\n\n/*两仪成,我们用伪元素来画2个小圆。首先还是加border*/\n#yinyang::before{\n    border: 1px solid green;\n    /* 绝对定位 */\n    position: absolute;\n    top: 50px;\n    width: 100px;\n    height: 100px;\n    border-radius: 50%;\n    background:#ffffff;\n \n\n    display: block;\n    content: \"\";\n}\n#yinyang::after{\n    border: 1px solid yellow;\n    /* 绝对定位 */\n    position: absolute;\n    top:50px;\n    right: 0;\n    width: 100px;\n    height: 100px;\n    border-radius: 50%;\n    background: #000000;\n    display: block;\n    content: \"\";\n}\n/*\n\n这样就用伪元素代替了2个div 但是被代替的两个div里面还有div呢？\n那么伪元素里面还可以装一个伪元素吗？是不行的。\n最后两个最小的圆怎么做？\n用border来做。\nborder 自己调整大小 宽高 颜色\n\n*/\n#yinyang::before{\n    content: \"\";\n    /* 用border来做最后两个最小的圆 因为设置了border大小所以八卦宽高自己调整 */\n    border:40px solid #000000;\n}\n#yinyang::after{\n    content: \"\";\n        /* 用border来做最后两个最小的圆 因为设置了border大小所以八卦宽高自己调整 */\n    border:40px solid #ffffff;\n}\n\n/*声明关键帧，这个动画一些关键的位置*/\n@keyframes spin {\n  /* 一开始的位置 */\n  form {\n    /* 一开始转0度 */\n    transform: rotate(0deg);\n  }\n  /* 最后 转360度*/\n  to {\n    transform: rotate(360deg);\n  }\n}\n#yinyang{\n  /*加动画 去声明关键帧 然后 怎么一直转 加infinite意思无限的*/\n  /* 转的也太不自然了吧 加一个linear 线性的转  感觉快就调大，1s一圈改10s一圈试试*/\n  /* 参数顺序不重要 会自动匹配 */\n  animation: spin 10s infinite linear; \n}\n/*\n太极不明显,加阴影。\n*/\n#yinyang{\n  /*加动画 去声明关键帧 然后 怎么一直转 加infinite意思无限的*/\n  /* 转的也太不自然了吧 加一个linear 线性的转  感觉快就调大，1s一圈改10s一圈试试*/\n  /* 参数顺序不重要 会自动匹配 */\n  animation: spin 10s infinite linear;\n    /* 总觉八卦不明显 加一个css3属性 阴影 */\n  /* 不会用就搜 你要的属性+generator */\n  box-shadow: 0px 0px 5px 3px rgba(0, 0, 0, 0.75); \n}\n\n\n`;\nlet string2 = ''\n// 这个replace只会把第一个回车变成换行\n// 我们要用到正则表达式了\n// 然后又发现了一个bug 他会打出<来\n// string=string.replace(/\\n/g,\"<br>\")\nlet n = 0\n// 通过setTimeout模拟了setInterval\n// 这样做的好处是可以随时停止\nlet step = () => {\n    setTimeout(() => {\n        if(html){\n            if (string[n] === '\\n') {\n                string2 += '<br>'\n            } else if (string[n] === ' ') {\n                // 如果是空格\n                string2 += '&nbsp'\n            } else {\n                // 如果不是回车就照搬\n                string2 += string[n]\n            }\n            html.innerHTML = string2\n            if(style){\n                style.innerHTML = string.substring(0, n)\n            }\n            window.scrollTo(0,9999)\n            html.scrollTo(0,9999)\n            if (n < string.length - 1) {\n                // 不是最后一个\n                step();\n                n++\n            } else { }\n        }\n\n    }, 30)\n}\nstep()\n\n// console.log(yinyang)\n// // 设置个开关 来判断什么时候可以拖拽什么时候停下。\n// var dragging: boolean = false\n\n// // 记录鼠标位置\n// var position = [0, 0]\n// // div1 不为空执行下面\n// if(yinyang){\n// // 鼠标点下不松\n// yinyang.onmousedown = function(e){\n\n//     dragging = true\n//         // 鼠标按下的时候记录鼠标位置\n//     position = [e.clientX,e.clientY]\n// }\n\n// document.onmousemove = function(e){\n//         // console.log(e.clientX, e.clientY)\n//         if(dragging === true){\n//             // console.log(e.clientX, e.clientY)\n//             var deltaX = e.clientX - position[0]\n//             var deltaY = e.clientY - position[1]\n//             if(yinyang){\n//             // 由于js有bug div.style.top只有取得内敛样式里面的值 并不能取得 外链css里面的值\n//             console.log('yinyang.style.top')\n//             console.log(yinyang.style.top)\n\n//             var top = parseInt(yinyang.style.top) || 0\n//             var left = parseInt(yinyang.style.left) || 0\n//             // 防止div跑出页面 下面是 防止往左和防止放上 那么如果往右和往下呢？\n//             var resultY = top + deltaY\n//             var resultX = left + deltaX\n//             // if(resultY < 0){\n//             //     resultY = 0\n//             // }\n//             // if(resultX< 0){\n//             //     resultX = 0\n//             // }\n//             yinyang.style.top = resultY + 'px'\n//             yinyang.style.left = resultX + 'px'\n//             // 然后发现数值很离谱 那是因为我们应该是每次移动和上次的位置对比\n//             position[0] = e.clientX\n//             position[1] = e.clientY\n//         }\n//     }\n// }\n//     // 鼠标松开\n//     document.onmouseup = function(){\n//         dragging = false\n//     }\n// }"],"names":["console","log","$6efd407a02dd5b042b14d14bdd79844a$var$html","document","getElementById","$6efd407a02dd5b042b14d14bdd79844a$var$style","querySelector","$6efd407a02dd5b042b14d14bdd79844a$var$string","$6efd407a02dd5b042b14d14bdd79844a$var$string2","$6efd407a02dd5b042b14d14bdd79844a$var$n","$6efd407a02dd5b042b14d14bdd79844a$var$step","setTimeout","innerHTML","substring","window","scrollTo","length"],"version":3,"file":"index.HASH_REF_c0efb059cc39263c6ef7a1fb7eeea09d.js.map"}